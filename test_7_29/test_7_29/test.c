#define _CRT_SECURE_NO_WARNINGS 1

// 操作符详解
#include <stdio.h>

// 1.算术操作符
int main()
{
	int ret1 = 9 / 2;
	printf("%d\n", ret1); // 4
	// 对于 /(除号) 两边都是整数，执行的是整数除法

	double ret2 = 9 / 2.0;
	printf("%lf\n", ret2); // 4.500000

	// % - 取模
	// & 取模操作符只能针对整型类型

	return 0;
}



// 2.左移操作符 右移操作符
int main()
{
	int a = 5; // 4byte = 32bit
	int b = a << 1;
	//00000000000000000000000000000101 - 正整数 原反补相同
	//00000000000000000000000000000101
	//00000000000000000000000000000101

	int c = -1;
	int d = c << 1;
	//10000000000000000000000000000001 - -1的原码
	//11111111111111111111111111111110 - 反码
	//11111111111111111111111111111111 - 补码

	// 移位操作符，移动的是二进制位
	// 对于整数的二进制有3种表示形式：原码，反码，补码
	// 正整数 - 原码，反码，补码相同
	// 负整数：
	// 原码 - 直接按照数字的正负写出的二进制序列
	// 反码 - 原码的符号位不变，其它位按位取反得到的
	// 补码 - 反码+1
	// 整数在内存中存储的是二进制的补码

	return 0;
}


// 左移操作符
int main()
{
	// << 左边丢弃，右边补0

	int a = 5;
	int b = a << 1;
	printf("%d\n", b); // 10

	int c = -1;
	int d = c << 1;
	printf("%d\n", d); // -2 打印的是原码的值
	//11111111111111111111111111111111 - -1补码
	// (1)1111111111111111111111111111111(0) - 左移 左边丢弃右边补0
	//1111111111111111111111111111111(0) - -1左移1的补码
	//11111111111111111111111111111101 - 反
	//10000000000000000000000000000010 - 原 -2

	return 0;
}


// 右移操作符
int main()
{
	// 右移运算分两种：
	// 逻辑移位--右边丢弃，左边补0
	// 算术移位--右边丢弃，左边补原符号位（VS2019采用算术右移）

	int a = -1;
	int b = a >> 1;
	printf("%d\n", b);
	//11111111111111111111111111111111 - -1补码
	//()1111111111111111111111111111111(1)
	// 如果是逻辑移位就补0
	// 如果是算术移位就补1 结果是还是-1（当前是算术移位）

	return 0;
}


// 对于移位运算符，不要移动负数位，这是标准未定义的
int main()
{
	int a = 15;
	int b = a >> -1; // err - 标准为定义行为

	return 0;
}


// 对于移位操作符 操作数必须是整数
int main()
{
	float c = 4.5f;
	c >> 1; // err
}



// 3.位操作符
// （他们的操作数必须是整数）
// & 按位与
// | 按位或
// ^ 按位异或


// &按位与：只要有0就是0，两个同时为1才是1
int main()
{
	int a = 3;
	int b = -2;
	int c = a & b;
	printf("%d\n", c);
	// 00000000000000000000000000000011 - 3

	// 10000000000000000000000000000010 - -2的原码
	// 11111111111111111111111111111101 - -2的反码
	// 11111111111111111111111111111110 - -2的补码

	// 00000000000000000000000000000011 - 3补码
	// 11111111111111111111111111111110 - -2的补码
	// 00000000000000000000000000000010 - a&b

	// %d - 说明我们要打印c的值，以有符号的形式
	// 00000000000000000000000000000010 - a&b
	// 正数 原反补相同 2

	return 0;
}


// | 按位或：只要有1就是1
int main()
{
	int a = 3;
	int b = -2;
	int c = a | b;
	printf("%d\n", c);

	// 00000000000000000000000000000011 - 3补码
	// 11111111111111111111111111111110 - -2的补码
	// 11111111111111111111111111111111 - a|b

	// 以%d打印
	// 算的是补码 最高位是负 要算原码
	// 11111111111111111111111111111111 - a|b 补码
	// 11111111111111111111111111111110 - 反
	// 10000000000000000000000000000001 - 原 -1

	return 0;
}


// ^ 按位异或：相同为0，相异为1
int main()
{
	int a = 3;
	int b = -2;
	int c = a ^ b; // 二进制位异或
	printf("%d\n", c);

	// 00000000000000000000000000000011 - 3补码
	// 11111111111111111111111111111110 - -2的补码
	// 11111111111111111111111111111101 - a^b

	// %d打印 负数计算原码
	// 11111111111111111111111111111101 - a^b 补
	// 11111111111111111111111111111100 - 反
	// 10000000000000000000000000000011 - 原 -3

	return 0;
}



int main()
{
	// 可以求a的二进制序列的最低位是多少
	int a = 15;
	a & 1;
	// 00000000000000000000000000001111 - 15
	// 00000000000000000000000000000001 - 1
	// 00000000000000000000000000000001 - a&1

	return 0;
}


int main()
{
	// 可以统计所有的的内存中的补码二进制序列位有多少个1 循环32次
	int a = 15;
	a & 1;
	a = a >> 1; // 让每一位都有机会来到最低位

	return 0;
}



// 一道变态的面试题
// 不能创建临时变量（第三个变量），实现两个数的交换。

//使用变量
int main()
{
	int a = 3;
	int b = 5;
	int tmp = 0;
	tmp = a;
	a = b;
	b = tmp;

	printf("a=%d b=%d\n", a, b);

	return 0;
}


// 存在溢出的问题
int main()
{
	int a = 3;
	int b = 5;

	a = a + b;
	b = a - b; // 和减b是a  此时b是a
	a = a - b; // 和减b（此时是a）是a 

	printf("a=%d b=%d\n", a, b);

	return 0;
}


// 用按位异或
int main()
{
	int a = 3;
	int b = 5;

	a = a ^ b;
	// 011      
	// 101        b
	// 110 a^b    a
	b = a ^ b;
	// 110        a
	// 101
	// 011 a^b    b
	a = a ^ b;
	// 110
	// 011        b
	// 101        a

	// a^b得出一个密码 密码与原来的a^得到原来的b 密码与原来的b^得到原来的a

	printf("a=%d b=%d\n", a, b);

	return 0;
}


// a^a=0       对应的二进制位都相同，都为0
// 0^a=a       000 011--011
// a^a^b=b     a^a=0  0^b=b
// a^b^a=b
// 异或是支持交换律的


// 用变量求最好 用异或代码的可读性不够好，且只适用于整形



// 4.赋值操作符
// 赋值操作符可以连续赋值（不建议）
int main()
{
	int a = 10;
	int x = 0;
	int y = 20;
	a = x = y + 1; // 连续赋值

	// 清晰且便于调试
	x = y + 1;
	a = x;

	return 0;
}


// 复合赋值符
// += -= *= /= %= >>= <<= &= |= ^=
int main()
{
	int a = 10;
	a = a >> 1;
	a >>= 1; // 符合赋值

	a = a + 10;
	a += 10;

	return 0;
}



// 5.单目操作符：只有一个操作数的操作符

// !  逻辑反操作
// - 负值    +正值
// &  取地址
// sizeof  操作数的类型长度（以字节为单位）
// ~ 对一个数的二进制按位取反
// -- ++ 前置，后置-- ++
// * 间接访问操作符（解引用操作符）
// (类型)  强制类型转换

// ! 真变假 假变真
int main()
{
	int a = 5;
	int b = !a;
	printf("%d\n", b); // 0

	int c = 0;
	int t = !c;
	printf("%d\n", t); // 1

	return 0;
}


int main()
{
	int a = 10;
	if (a) // a为真打印hehe
	{
		printf("hehe\n");
	}
	if (!a) // a为假打印haha
	{
		printf("haha\n");
	}
	return 0;
}


// - 负值    +正值
int main()
{
	int a = 10;
	a = -a;
	printf("a=%d\n", a); // -10
	a = -a;
	printf("a=%d\n", a); // 10
	return 0;
}


// & 取地址  *解引用操作符
int main()
{
	int a = 10;
	int* p = &a;

	*p = 20;
	printf("%d\n", a);

	return 0;
}


// *p 左值右值
// 左值 - 指向的空间
// 右值 - 空间里的内容
int main()
{
	int a = 10;
	int* p = &a;

	int b = *p; // 指向那块空间的值 赋给b

	*p = 20; // 通过解引用找到a的空间 把空间改成20
	printf("%d\n", a);

	return 0;
}


// 数组也可以&
int main()
{
	int arr[10] = { 0 };

	arr + 1; // 取首元素的地址
	&arr[0] + 1; // 取首元素的地址

	&arr + 1; // 取出数组的地址

	// 此三个地址一样，但意义不同 
	// 加1 前两个加4 后一个加40

	return 0;
}



// sizeof
// sizeof是操作符，不是函数
// sizeof是计算变量或者类型创建变量的内存大小，单位是字节，和内存中存放什么数据没有关系
int main()
{
	char arr[10] = "abc";
	printf("%d\n", sizeof(arr)); // 10
	printf("%d\n", strlen(arr)); // 3 字符串的长度，计算的是\0之前出现的字符个数
	return 0;
}


int main()
{
	int a = 10;
	printf("%d\n", sizeof(a)); // 4
	printf("%d\n", sizeof(int)); // 4

	return 0;
}


int main()
{
	int a = 5;
	short s = 10;
	printf("%d\n", sizeof(s = a + 2));
	printf("%d\n", s);

	// sizeof内部的表达式是不参与运算的！

	// 源文件sizeof变成可执行程序test.exe 会经过编译和链接 生成.exe后运行
	// 最终取决于short的类型 大小是2 在链接是已经是2 在运行时没有机会执行
	// 2 10
	return 0;
}



// ~ 对一个数的二进制按位取反（所有位）
int main()
{
	int a = 0;
	int b = ~a;
	printf("%d\n", b);

	// 00000000000000000000000000000000
	// 11111111111111111111111111111111 - -1的二进制位补码是全1
	// 打印%d 转原码
	// 11111111111111111111111111111110 - 反
	// 10000000000000000000000000000001 - 原 -1
	return 0;
}


// 使用 改二进制位的数再改回来
int main()
{
	int a = 13;
	// 00000000000000000000000000001101 - 正数原反补相同
	a |= (1 << 1);
	printf("%d\n", a);
	// 1左移1  00000000000000000000000000000010
	// 按位或等到a  00000000000000000000000000001111  - 15


	// 00000000000000000000000000001111  - 15 此时的a
	// 11111111111111111111111111111101 只要用这个&就可以改回来
	// 这个二进制序列是由1<<1再按位取反得到
	a &= (~(1 << 1));
	printf("改回来%d\n", a);

	return 0;
}



// -- ++前置，后置-- ++
int main()
{
	int a = 10;
	int b = a++; // 后置++，先使用，后++
	printf("%d\n", b); // 10
	printf("%d\n", a); // 11

	int c = 10;
	int e = ++c; // 前置++，先++，后使用
	printf("%d\n", e); // 11
	printf("%d\n", c); // 11

	return 0;
}


//err
int main()
{
	int a = 1;
	int b = (++a) + (++a) + (++a); // err
	printf("b=%d\n", b); // 12 在不同编译器上结果不同
	return 0;
}



// (类型)强制类型转换
int main()
{
	int a = (int)3.14; // 默认写出的是浮点数是double的
	printf("%d\n", a);

	return 0;
}



// sizeof和数组
// 1 2 3 4 分别输出多少？
void test1(int arr[])
{
	printf("%d\n", sizeof(arr));//(2)
}
void test2(char ch[])
{
	printf("%d\n", sizeof(ch));//(4)
}
int main()
{
	int arr[10] = { 0 };
	char ch[10] = { 0 };
	printf("%d\n", sizeof(arr));//(1)
	printf("%d\n", sizeof(ch));//(3)
	test1(arr);
	test2(ch);
	return 0;
}
// 数组名是单独放在sizeof内部，数组名表示整个数组计算的是整个数组的大小
// &数组名，数组名表示整个数组，取出的是整个数组的地址

// 10个整形 40个字节。10个字符 10个字节
// 数组传参 首元素地址  本质上是void test1(int* arr)  求的是指针大小 4/8
// 40 4 10 4



// 6.关系操作符
// >  >=  <  <=  !=用于测试“不相等”  ==用于测试“相等”
// 用于同类型变量
// 注意==与=写错导致的错误



// 7. 逻辑操作符
// &&    逻辑与
// ||    逻辑或

// 只关注真假
// 逻辑与判断的真用1表示 假用0表示
// 逻辑与两个都为真是1 逻辑或只要有一个为真就是1
int main()
{
	int a = 0;
	int b = 5;

	int c = a && b; // 逻辑与
	int e = a || b; // 逻辑或
	printf("c=%d\n", c); // 0
	printf("e=%d\n", e); // 1

	return 0;
}

// 区分==逻辑与==与和==按位与==
// 区分==逻辑或==与和==按位或==
// 1&2 ----0
// 1&&2---->1
// 
// 1 | 2----->3
// 1 || 2---- > 1


// 逻辑与和或的特点：
// 360笔试题
int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	i = a++ && ++b && d++;
	//i = a++||++b||d++;
	printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
	return 0;
}
// a++先使用后++ 所以0为假 后面不运算 a++是1 bcd都没有变  1 2 3 4
// 对于逻辑与来说，左边为假，右边就不用计算了

int main()
{
	int i = 0, a = 1, b = 2, c = 3, d = 4;
	i = a++ && ++b && d++;
	printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
	// 改a=1，2 3 3 5
	return 0;
}

int main()
{
	int i = 0, a = 1, b = 2, c = 3, d = 4;
	i = a++ || ++b || d++;
	printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
	// a++是假 后面不用算了 只有a++了 2 2 3 4
	return 0;
}

int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	i = a++ || ++b || d++;
	printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
	// 1 3 3 4 ab自增
	return 0;
}



// 8.条件操作符（三目操作符）
// exp1 ? exp2 : exp3
// 使用条件表达式实现找两个数中较大值
int main()
{
	int a = 3;
	int b = 5;
	int m = 0;
	m = (a > b ? a : b);
	// 如果a>b 就把a赋给m 否则将b赋给m
	// (a > b) ? (m = a) : (m = a);
}



// 9.逗号表达式
// exp1, exp2, exp3, …expN
// 逗号表达式，就是用逗号隔开的多个表达式。 
// 逗号表达式，==从左向右依次执行==。==整个表达式的结果是最后一个表达式的结果==。
int main()
{
	//代码1
	int a = 1;
	int b = 2;
	int c = (a > b, a = b + 10, a, b = a + 1);//逗号表达式

	//代码2
	if (a = b + 1, c = a / 2, d > 0) // 前面依次计算 最后一个是if的判断条件

	//代码3
		a = get_val();
	count_val(a);
	while (a > 0)
	{
		//业务处理
		a = get_val();
		count_val(a);
	}

	//如果使用逗号表达式，改写：
	while (a = get_val(), count_val(a), a > 0)
	{
		//业务处理
	}
}