#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

//写程序判断当前机器的字节序
int main()
{
	int a = 1;
	char* p = (char*)&a;
	if (*p == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}

	return 0;
}


//函数
int cheek_sys()
{
	int a = 1;
	char* p = (char*)&a;
	/*if (*p == 1)
		return 1;
	else
		return 0;*/
	//1
	return *p;
}

//优化2
int cheek_sys()
{
	int a = 1;
	return *(char*)&a;
}

int main()
{
	int ret = cheek_sys();
	if (1 == ret)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
}



//练习1
int main()
{
	char a = -1;
	//10000000000000000000000000000001原
	//11111111111111111111111111111110反
	//11111111111111111111111111111111补
	//11111111 - a 只能存8个bit，截断
	//%d - 以有符号整数的形式打印
	//整型提升 补符号位
	//11111111111111111111111111111111 - 补
	//打印原码
	//11111111111111111111111111111110
	//10000000000000000000000000000001 -1

	signed char b = -1;
	//11111111 - b
	//与a一样 -1

	unsigned char c = -1;
	//11111111 - c
	//无符号整型提升高位补0
	//00000000000000000000000011111111
	//%d打印 正数原反补相同

	printf("a=%d,b=%d,c=%d", a, b, c);
	//-1 -1 255
	return 0;
}


//2
int main()
{
	//char -128~127
	char a = -128;
	//10000000000000000000000010000000
	//11111111111111111111111101111111
	//11111111111111111111111110000000
	//10000000
	//11111111111111111111111110000000 整型提升
	//以无符号打印 补码即原码 4,294,967,168

	printf("%u\n", a);
	//%u - 打印无符号整型
	return 0;
}


//3
int main()
{
	char a = 128;
	//00000000000000000000000010000000 正数
	//10000000 -a
	//11111111111111111111111110000000 整型提升
	//与-128存入内存的值一样 4294967168

	printf("%u\n", a);
	return 0;
}


//4
int main()
{
	int i = -20;
	unsigned int j = 10;

	//10000000000000000000000000010100 -20
	//11111111111111111111111111101011
	//11111111111111111111111111101100  -20补码

	//00000000000000000000000000001010  10原反补
	
	//11111111111111111111111111110110 -20+10补
	//11111111111111111111111111110101
	//10000000000000000000000000001010 补
	//-10

	printf("%d\n", i + j);

	return 0;
}


//5
#include <windows.h>

int main()
{
	unsigned int i;
	//无符号 所有二进制序列都是有效位 不会小于0 判断恒成立
	//9 8 7 6 5 4 3 2 1 0 -1
	//-1在内存中是全1
	//11111111111111111111111111111111 无符号 都是有效位
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n", i);
		Sleep(1000);
	}

	//死循环
	return 0;
}


//6
int main()
{
	char a[1000];
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	printf("%d", strlen(a));
	//strlen找\0 \0de ASCII码值是0 就是找0
	//有符号char范围：-128~127  一个圈0 1 2。。。127 -128。。。-3 -2 -1
	
	//减 倒着转-1 -2...-128 127。。。5 4 3 2 1 0 -1 -2。。。
	//找0 一共128+127=255
	return 0;
}
//signed short 
//-32768 ~ 32767
//-32768 ~ -1  0 ~ 32767


//7
unsigned char i = 0;

int main()
{
	for (i = 0; i <= 255; i++)
	{
		printf("hello world\n");
	}
	//unsigned char取值范围：0~255

	return 0;
}



//浮点型在内存中的存储
//float,double,long double
//浮点型表示的范围在float.h中定义

//INT_MAX
//INT_MIN
//整形定义在limits.h中
//#include <limits.h>
//INT_MAX;
//右击转到定义


int main()
{
	int n = 9;
	float* pFloat = (float*)&n;

	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);
	
	*pFloat = 9.0;
	printf("num的值为：%d\n", n);
	printf("*PFloat的值为：%f\n", *pFloat);

	return 0;
}

//浮点数存储规则
//1、规则
//IEEE 754
//(-1)^S *M *2^E
//(-1)^S  符号位，当s=0时，正数；s=1时，负数
//M       有效数字 大于等于1，小于2
//2^E     指数位

/* 例 十进制数5.5
101.1             2^2  2^0  2^-1
1.011*2^2
(-1)*0 *1.011 *2^2
S = 0
M = 1.011
E = 2 */

/*例9.0
1001.0
1.001*2^3
(-1)^0 *1.001 *2^3
S = 0
M = 1.001
E = 3 */

//32位的浮点数float：
//最高一位是符号位s 下面8位是指数作为E 剩下23位是有效数字M
//S(1bit)  E(8bit)  M(23bit)

//64位浮点数double：
//最高一位是符号位s 下面11位是指数作为E 剩下52位是有效数字M
//S(1bit)  E(11bit)  M(52bit)

//2、浮点数的存储
//M的规定：
//1<=M<2 
/*在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。
比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。
以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。*/

//指数E：
//把E当做无符号数
/* 首先，E为一个无符号整数（unsigned int） 这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的
取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真
实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E
是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。 */

int main()
{
	float f = 5.5f;
	//101.1
	//(-1)^0 *1.011 *2^2
	//S = 0
	//M = 1.011
	//E = 2      存储：+127=129   10000001
	//内存里：0 10000001 01100000000000000000000  M补23位
	//16进制：40 B0 00 00   小端：00 00 b0 40
	return 0;
}


//3、浮点数如何取出
//指数E从内存中取出还可以再分成三种情况：
/*E不全为0或不全为1
指数E的计算值减去127（或1023），得到真实值，再将有效数字M前
加上第一位的1。 比如： 0.5（1 / 2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，
则为1.0 * 2 ^ (-1)，其阶码为 - 1 + 127 = 126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位
00000000000000000000000，则其二进制表示形式为:0 01111110 00000000000000000000000

E全为0
这时，浮点数的指数E等于1-127（或者1-1023）即为真实值， 有效数字M不再加上第一位的1，而是还原为
0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。

E全为1
E是128，表示±无穷大（正负取决于符号位s）；*/

int main()
{
	int n = 9;
	//00000000000000000000000100000000

	float* pFloat = (float*)&n;

	printf("n的值为：%d\n", n); //9
	printf("*pFloat的值为：%f\n", *pFloat);
	//浮点数序列
	//0 00000000 00000000000000100000000
	//E为全0
	//E直接是1-127=-126
	//M= 0.00000000000000100000000
	//0.00000000000000100000000 *2^-126
	//%f只打印6位 0.000000

	*pFloat = 9.0;
	printf("num的值为：%d\n", n);
	//1001.0
	//(-1)^0 *1.001 *2^3
	//S=0
	//E=3     +127
	//M=1.001
	//0 10000010 00100000000000000000000
	//%d的打印 有符号 正数原反补相同
	//1,091,567,616

	printf("*PFloat的值为：%f\n", *pFloat);
	//9.000000

	return 0;
}